{"version":3,"sources":["webpack://darwin/webpack/universalModuleDefinition","webpack://darwin/webpack/bootstrap","webpack://darwin/./src/MutationMethod.ts","webpack://darwin/./src/CrossoverMethods.ts","webpack://darwin/./src/Darwin.ts","webpack://darwin/./src/Chromosome.ts","webpack://darwin/./src/EventEmitter.ts","webpack://darwin/./src/Utils.ts"],"names":["root","factory","exports","module","define","amd","window","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","MutationMethod","CrossoverMethod","Chromosome_1","CrossoverMethods_1","MutationMethod_1","Utils_1","Darwin","[object Object]","params","population","generation","on_fitness_update","stats","needs_update","population_size","chromo","Chromosome","chromosome_length","rand_func","on","push","assign","crossover_rate","mutation_rate","crossover_method","SINGLE_POINT","mutation_method","FLIP","elite_count","elite_copies","fittest","avg_fitness","sum_fitness","fittest_idx","new_pop","elite","getTopChromosomes","j","clone","length","Math","random","mum","getRandomChromosome","dad","babies","crossover","baby1","baby2","pop","mutate","fitness_evaluator","setFitness","getGenes","duplicateElite","updateStats","idx","floor","acc_fitness","getFitness","count","selectKBest","force_update","max_fitness","fitness","EventEmitter_1","EventEmitter","length_or_bits","super","bits","f","emit","bob","min","mut_rate","tmp","method","mutate_flip","SWAP","mutate_swap","setBits","b1","b2","p1","p2","swap","diff_bits","N","slice","splice","inf","sup","max","undefined","indexOf","crossover_single_point","TWO_POINT","crossover_two_point","UNIFORM","crossover_uniform","HALF_UNIFORM","crossover_half_uniform","ORDERED","crossover_ordered","Error","copy","ev","handler","handlers","Map","has","set","em","_quicksort","arr","from","to","pivot","partition","array","left","right","k","reverse_partial_quicksort"],"mappings":"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","file":"darwin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"darwin\"] = factory();\n\telse\n\t\troot[\"darwin\"] = factory();\n})((typeof window !== 'undefined' ? window : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MutationMethod;\n(function (MutationMethod) {\n    MutationMethod[MutationMethod[\"FLIP\"] = 0] = \"FLIP\";\n    MutationMethod[MutationMethod[\"SWAP\"] = 1] = \"SWAP\";\n})(MutationMethod = exports.MutationMethod || (exports.MutationMethod = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar CrossoverMethod;\n(function (CrossoverMethod) {\n    CrossoverMethod[CrossoverMethod[\"SINGLE_POINT\"] = 0] = \"SINGLE_POINT\";\n    CrossoverMethod[CrossoverMethod[\"TWO_POINT\"] = 1] = \"TWO_POINT\";\n    CrossoverMethod[CrossoverMethod[\"UNIFORM\"] = 2] = \"UNIFORM\";\n    CrossoverMethod[CrossoverMethod[\"HALF_UNIFORM\"] = 3] = \"HALF_UNIFORM\";\n    CrossoverMethod[CrossoverMethod[\"ORDERED\"] = 4] = \"ORDERED\";\n})(CrossoverMethod = exports.CrossoverMethod || (exports.CrossoverMethod = {}));\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Chromosome_1 = require(\"./Chromosome\");\nconst CrossoverMethods_1 = require(\"./CrossoverMethods\");\nconst MutationMethod_1 = require(\"./MutationMethod\");\nconst Utils_1 = require(\"./Utils\");\nclass Darwin {\n    constructor(params) {\n        this.population = [];\n        this.generation = 0;\n        const on_fitness_update = () => { this.stats.needs_update = true; };\n        for (let i = 0; i < params.population_size; i++) {\n            const chromo = new Chromosome_1.Chromosome(params.chromosome_length, params.rand_func);\n            chromo.on('update_fitness', on_fitness_update);\n            this.population.push(chromo);\n        }\n        this.params = Object.assign({ crossover_rate: 0.7, mutation_rate: 1 / params.chromosome_length, crossover_method: CrossoverMethods_1.CrossoverMethod.SINGLE_POINT, mutation_method: MutationMethod_1.MutationMethod.FLIP, elite_count: 1, elite_copies: 1 }, params);\n        this.stats = {\n            fittest: this.population[0],\n            avg_fitness: 0,\n            sum_fitness: 0,\n            fittest_idx: 0,\n            needs_update: true\n        };\n    }\n    duplicateElite(new_pop) {\n        // ELITISM i.e. keeping the fittest Chromosomes\n        if (this.params.elite_count > 0) {\n            const elite = this.getTopChromosomes(this.params.elite_count);\n            // Keep the fittest Chromosomes\n            new_pop.push(...elite);\n            // Duplicate the elite\n            for (let i = 0; i < this.params.elite_count; i++) {\n                for (let j = 0; j < this.params.elite_copies; j++) {\n                    new_pop.push(elite[i].clone());\n                }\n            }\n        }\n    }\n    crossover(new_pop) {\n        while (new_pop.length < this.params.population_size) {\n            if (Math.random() < this.params.crossover_rate) {\n                const mum = this.getRandomChromosome();\n                const dad = this.getRandomChromosome();\n                const babies = mum.crossover(dad, this.params.crossover_method);\n                const baby1 = new Chromosome_1.Chromosome(babies.baby1, this.params.rand_func);\n                const baby2 = new Chromosome_1.Chromosome(babies.baby2, this.params.rand_func);\n                new_pop.push(baby1, baby2);\n            }\n        }\n        // Because we add two chromosomes per loop\n        // if population_size is odd\n        if (this.params.population_size % 2 === 1) {\n            new_pop.pop();\n        }\n    }\n    mutate(new_pop) {\n        for (const c of new_pop) {\n            c.mutate(this.params.mutation_rate, this.params.mutation_method);\n            // c.setFitness(0); // reset fitness\n        }\n    }\n    updateFitness(fitness_evaluator) {\n        for (const chromo of this.population) {\n            chromo.setFitness(fitness_evaluator(chromo.getGenes()));\n        }\n        this.stats.needs_update = true;\n    }\n    // generates the new generation\n    // the fitness of each Chromosome must be updated before calling mate\n    mate() {\n        const new_pop = [];\n        // ELITISM\n        this.duplicateElite(new_pop);\n        // REPRODUCTION\n        this.crossover(new_pop);\n        this.mutate(new_pop);\n        // uptate the population\n        this.population = new_pop;\n        this.generation++;\n        this.updateStats(true);\n    }\n    // Getters & Setters\n    getPopulation() {\n        return this.population;\n    }\n    getChromosome(idx) {\n        return this.population[idx];\n    }\n    getRandomChromosome() {\n        this.updateStats();\n        if (this.stats.sum_fitness === 0) {\n            return this.population[Math.floor(Math.random() * this.population.length)];\n        }\n        const r = Math.random() * this.stats.sum_fitness;\n        let acc_fitness = 0;\n        for (let i = 0; i < this.population.length; i++) {\n            acc_fitness += this.population[i].getFitness();\n            if (acc_fitness > r) {\n                return this.population[i];\n            }\n        }\n        // this should never happend\n        return this.population[0];\n    }\n    getTopChromosomes(count) {\n        // return this.population.sort((a, b) => b.getFitness() - a.getFitness()).slice(0, count);\n        return Utils_1.selectKBest(this.population, count);\n    }\n    getAverageFitness() {\n        if (this.stats.needs_update) {\n            this.updateStats();\n        }\n        return this.stats.avg_fitness;\n    }\n    getFittest() {\n        if (this.stats.needs_update) {\n            this.updateStats();\n        }\n        return this.stats.fittest;\n    }\n    getParams() {\n        return this.params;\n    }\n    getGeneration() {\n        return this.generation;\n    }\n    getStats() {\n        return this.stats;\n    }\n    updateStats(force_update = false) {\n        if (force_update || this.stats.needs_update) {\n            let sum_fitness = 0;\n            let max_fitness = 0;\n            let fittest_idx = 0;\n            for (let i = 0; i < this.population.length; i++) {\n                const fitness = this.population[i].getFitness();\n                sum_fitness += fitness;\n                if (fitness > max_fitness) {\n                    max_fitness = fitness;\n                    fittest_idx = i;\n                }\n            }\n            this.stats.sum_fitness = sum_fitness;\n            this.stats.avg_fitness = sum_fitness / this.params.population_size;\n            this.stats.fittest = this.population[fittest_idx].clone();\n            this.stats.fittest_idx = fittest_idx;\n            this.stats.needs_update = false;\n        }\n    }\n}\nexports.Darwin = Darwin;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MutationMethod_1 = require(\"./MutationMethod\");\nconst CrossoverMethods_1 = require(\"./CrossoverMethods\");\nconst EventEmitter_1 = require(\"./EventEmitter\");\nclass Chromosome extends EventEmitter_1.EventEmitter {\n    constructor(length_or_bits, rand_func) {\n        super();\n        this.bits = [];\n        this.fitness = 0;\n        this.rand_func = rand_func;\n        if (typeof length_or_bits === 'number') {\n            this.length = length_or_bits;\n            for (let i = 0; i < this.length; i++) {\n                this.bits.push(rand_func());\n            }\n        }\n        else {\n            this.bits = length_or_bits;\n            this.length = length_or_bits.length;\n        }\n    }\n    getFitness() {\n        return this.fitness;\n    }\n    setFitness(f) {\n        this.fitness = f;\n        this.emit('update_fitness', f);\n    }\n    // returns the number of bits which are different = Hamming distance\n    compare(bob) {\n        let count = 0;\n        for (let i = 0; i < Math.min(this.length, bob.length); i++) {\n            count += this.bits[i] !== bob.bits[i] ? 1 : 0;\n        }\n        return count;\n    }\n    mutate_flip(mut_rate) {\n        for (let i = 0; i < this.length; i++) {\n            if (Math.random() < mut_rate) {\n                this.bits[i] = this.rand_func();\n            }\n        }\n    }\n    mutate_swap(mut_rate) {\n        for (let i = 0; i < this.length; i++) {\n            if (Math.random() < mut_rate) {\n                const j = Math.floor(Math.random() * this.length);\n                const tmp = this.bits[i];\n                this.bits[i] = this.bits[j];\n                this.bits[j] = tmp;\n            }\n        }\n    }\n    mutate(mut_rate = 1 / this.length, method) {\n        if (typeof method === 'number') {\n            switch (method) {\n                case MutationMethod_1.MutationMethod.FLIP:\n                    this.mutate_flip(mut_rate);\n                    break;\n                case MutationMethod_1.MutationMethod.SWAP:\n                    this.mutate_swap(mut_rate);\n                    break;\n            }\n        }\n        else {\n            this.setBits(method(this.getGenes()));\n        }\n    }\n    crossover_single_point(bob) {\n        const b1 = [];\n        const b2 = [];\n        const p = Math.floor(Math.random() * this.length);\n        for (let i = 0; i < this.length; i++) {\n            b1.push(i < p ? this.bits[i] : bob.bits[i]);\n            b2.push(i < p ? bob.bits[i] : this.bits[i]);\n        }\n        return { baby1: b1, baby2: b2 };\n    }\n    crossover_two_point(bob) {\n        const b1 = [];\n        const b2 = [];\n        let p1 = Math.floor(Math.random() * this.length);\n        let p2 = Math.floor(Math.random() * this.length);\n        if (p1 > p2) {\n            const c = p2;\n            p2 = p1;\n            p1 = c;\n        }\n        for (let i = 0; i < this.length; i++) {\n            b1.push(i < p1 ? this.bits[i] : (i < p2 ? bob.bits[i] : this.bits[i]));\n            b2.push(i < p1 ? bob.bits[i] : (i < p2 ? this.bits[i] : bob.bits[i]));\n        }\n        return { baby1: b1, baby2: b2 };\n    }\n    crossover_uniform(bob) {\n        const b1 = [];\n        const b2 = [];\n        for (let i = 0; i < this.length; i++) {\n            let swap = Math.random() < 0.5;\n            b1.push(swap ? bob.bits[i] : this.bits[i]);\n            b2.push(swap ? this.bits[i] : bob.bits[i]);\n        }\n        return { baby1: b1, baby2: b2 };\n    }\n    crossover_half_uniform(bob) {\n        let b1 = [];\n        let b2 = [];\n        let diff_bits = [];\n        for (let i = 0; i < this.length; i++)\n            if (this.bits[i] !== bob.bits[i])\n                diff_bits.push(i);\n        let N = diff_bits.length;\n        b1 = this.bits.slice();\n        b2 = bob.bits.slice();\n        for (let i = 0; i < N / 2; i++) {\n            let idx = Math.floor(Math.random() * diff_bits.length);\n            b1[diff_bits[idx]] = bob.bits[diff_bits[idx]];\n            b2[diff_bits[idx]] = this.bits[diff_bits[idx]];\n            diff_bits.splice(idx, 1);\n        }\n        return { baby1: b1, baby2: b2 };\n    }\n    crossover_ordered(bob) {\n        const b1 = [];\n        const b2 = [];\n        let inf = Math.floor(Math.random() * this.length), sup = Math.floor(Math.random() * this.length), tmp = inf;\n        inf = Math.min(inf, sup);\n        sup = Math.max(tmp, sup);\n        for (let i = inf; i < sup; i++) {\n            b1[i] = (inf <= i && i <= sup) ? bob.bits[i] : undefined;\n            b2[i] = (inf <= i && i <= sup) ? this.bits[i] : undefined;\n        }\n        for (let i = 0; i < this.length; i++) {\n            if (b1.indexOf(this.bits[i]) === -1) {\n                b1[i] = this.bits[i];\n            }\n            else {\n                for (let j = 0; j < this.length; j++) {\n                    if (b1.indexOf(this.bits[j]) === -1) {\n                        b1[i] = this.bits[j];\n                    }\n                }\n            }\n            if (b2.indexOf(bob.bits[i]) === -1) {\n                b2[i] = bob.bits[i];\n            }\n            else {\n                for (let j = 0; j < this.length; j++) {\n                    if (b2.indexOf(bob.bits[j]) === -1) {\n                        b2[i] = bob.bits[j];\n                    }\n                }\n            }\n        }\n        return { baby1: b1, baby2: b2 };\n    }\n    // public crossover(bob: Chromosome<T>, method: CrossoverMethod): Offspring<T>;\n    // public crossover(bob: Chromosome<T>, method: CustomCrossoverMethod<T>): Offspring<T>;\n    crossover(bob, method) {\n        if (typeof method === 'number') {\n            switch (method) {\n                case CrossoverMethods_1.CrossoverMethod.SINGLE_POINT:\n                    return this.crossover_single_point(bob);\n                case CrossoverMethods_1.CrossoverMethod.TWO_POINT:\n                    return this.crossover_two_point(bob);\n                case CrossoverMethods_1.CrossoverMethod.UNIFORM:\n                    return this.crossover_uniform(bob);\n                case CrossoverMethods_1.CrossoverMethod.HALF_UNIFORM:\n                    return this.crossover_half_uniform(bob);\n                case CrossoverMethods_1.CrossoverMethod.ORDERED:\n                    return this.crossover_ordered(bob);\n                default:\n                    throw new Error(`Unimplemented CrossoverMethod: ${method} (${CrossoverMethods_1.CrossoverMethod[method]})`);\n            }\n        }\n        return method(bob);\n    }\n    setBits(bits) {\n        this.bits = [...bits];\n    }\n    getGenes() {\n        return this.bits;\n    }\n    copy(bob) {\n        this.bits = bob.bits.slice();\n        this.rand_func = bob.rand_func;\n        this.fitness = bob.fitness;\n    }\n    clone() {\n        let c = new Chromosome(this.length, this.rand_func);\n        c.copy(this);\n        return c;\n    }\n}\nexports.Chromosome = Chromosome;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass EventEmitter {\n    constructor() {\n        // This Map is often unused, it is therfore best to initialize it only when needed\n        // i.e  when the on() method is called for the first time\n        // this.handlers = new Map<string, EventHandler[]>();\n    }\n    on(ev, handler) {\n        if (this.handlers === undefined) {\n            this.handlers = new Map();\n        }\n        if (this.handlers.has(ev)) {\n            this.handlers.get(ev).push(handler);\n        }\n        else {\n            this.handlers.set(ev, [handler]);\n        }\n    }\n    emit(ev, value) {\n        if (this.handlers !== undefined && this.handlers.has(ev)) {\n            for (const handler of this.handlers.get(ev)) {\n                handler.call(this, value);\n            }\n        }\n    }\n    bindEvent(em, ev) {\n        em.on(ev, value => this.emit(ev, value));\n    }\n}\nexports.EventEmitter = EventEmitter;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction selectKBest(array, k) {\n    // return array.sort((a, b) => b.getFitness() - a.getFitness()).slice(0, k);\n    reverse_partial_quicksort(array, k);\n    return array.slice(0, k);\n}\nexports.selectKBest = selectKBest;\nfunction _quicksort(arr, from = 0, to = arr.length - 1) {\n    const pivot = arr[Math.floor((from + to) / 2)].getFitness();\n    if (from < to) {\n        const p = partition(arr, from, to, pivot);\n        _quicksort(arr, from, p - 1);\n        _quicksort(arr, p, to);\n    }\n}\nfunction reverse_partial_quicksort(arr, k, from = 0, to = arr.length - 1) {\n    const pivot = arr[Math.floor((from + to) / 2)].getFitness();\n    if (from < to) {\n        const p = partition(arr, from, to, pivot);\n        _quicksort(arr, from, p - 1);\n        if (p < k) {\n            _quicksort(arr, p, to);\n        }\n    }\n}\nfunction partition(array, left, right, pivot) {\n    // put every element smaller than the pivot to its left\n    // and every element biffer to its right\n    // returning the pivot's position\n    while (left <= right) {\n        while (array[left].getFitness() > pivot) {\n            left++;\n        }\n        while (array[right].getFitness() < pivot) {\n            right--;\n        }\n        if (left <= right) {\n            [array[left], array[right]] = [array[right], array[left]];\n            left++;\n            right--;\n        }\n    }\n    return left;\n}\n"],"sourceRoot":""}